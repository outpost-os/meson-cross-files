[constants]
# Gcc triple, no diff between various arm-none-eabi targets, using
# supplementary arguments to precise
cross_triple = 'arm-none-eabi'
# llvm triple, target-explicit, needed by Rust
llvm_triple = 'thumbv7m-none-eabi'
cross_toolchain = '/opt/arm-none-eabi/'
cross_compile = cross_toolchain + 'bin/' + cross_triple + '-'

[host_machine]
system = 'baremetal'
cpu_family = 'arm'
cpu = 'cortex-m4'
endian = 'little'
exe_wrapper = 'qemu-arm-static'

[binaries]
c = cross_compile + 'gcc'
cpp = cross_compile + 'g++'
ar = cross_compile + 'gcc-ar'
ranlib = cross_compile + 'gcc-ranlib'
strip = cross_compile + 'strip'
objcopy = cross_compile + 'objcopy'
clang = 'clang'
rust_ld = 'gcc'
rust = 'rustc'
pkg-config = 'pkg-config'

[properties]
# when doing cross compilation, specific clang arguments are
# required in order to give bindgen enough information in order to properly generate
# the AST.
# This is done using documented properties (see machine files properties documentation)
# this may not be required depending on your distribution cross-toolchain configuration.
# If clang backend gcc, you need a cross-gcc toolchain detected by clang and having
# a correct sysroot path, so that standard iso c headers inclusion works.
# Here is an working example with standard ARM-packaged GCC toolchain
bindgen_clang_arguments = [ '--sysroot=' + cross_toolchain + cross_triple, '--target=' + llvm_triple ]
rust_target = llvm_triple
sysroot = cross_toolchain + cross_triple
